<!DOCTYPE html>
<html lang="ku" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ù†ÙˆÙˆØ³ÛŒÙ†ÛŒ Ù‡Û•ÙˆØ§ÛŒÛŒ â€” Ú©Ø§Ù…ÛØ±Ø§</title>

<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<style>
@import url('https://fonts.googleapis.com/css2?family=Noto+Naskh+Arabic:wght@400;700&family=Inter:wght@400;500;600;700&display=swap');

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RESET & VARIABLES â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
*{margin:0;padding:0;box-sizing:border-box;}
:root{
  --ink:#00f5d4;--bg:#0b0b16;--panel:#12122a;--panel2:#1a1a35;
  --accent:#f72585;--accent2:#7b2fff;--text:#e0e0ff;--text2:#8888aa;
  --border:#ffffff12;--glow:0 0 20px #00f5d480;--radius:8px;
  --topbar-h:44px;
  --transition:all .2s ease;
}
html,body{height:100%;overflow:hidden;background:var(--bg);color:var(--text);font-family:'Inter','Noto Naskh Arabic',sans-serif;}

::-webkit-scrollbar{width:5px;}
::-webkit-scrollbar-track{background:transparent;}
::-webkit-scrollbar-thumb{background:#ffffff20;border-radius:10px;}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LAYOUT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.app{display:grid;grid-template-columns:1fr;grid-template-rows:var(--topbar-h) 1fr 28px;height:100vh;width:100vw;}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TOPBAR â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.topbar{grid-column:1/-1;display:flex;align-items:center;padding:0 10px;background:var(--panel);border-bottom:1px solid var(--border);gap:4px;z-index:300;}

.tb-color-row{display:flex;align-items:center;gap:4px;}
.tb-swatch{width:22px;height:22px;border-radius:50%;cursor:pointer;border:2px solid transparent;transition:transform .15s, border-color .15s;flex-shrink:0;}
.tb-swatch:hover,.tb-swatch.active{transform:scale(1.25);border-color:#fff;}
.tb-color-current{width:26px;height:26px;border-radius:6px;border:2px solid #ffffff30;cursor:pointer;flex-shrink:0;position:relative;}
.tb-color-current input[type=color]{position:absolute;inset:0;opacity:0;cursor:pointer;width:100%;height:100%;}
.tb-size-slider{display:flex;align-items:center;gap:4px;}
.tb-size-slider input[type=range]{width:80px;-webkit-appearance:none;appearance:none;height:4px;background:#333;border-radius:2px;outline:none;}
.tb-size-slider input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:var(--ink);cursor:pointer;}
.tb-size-val{font-size:.68rem;color:var(--ink);min-width:18px;text-align:center;}
.topbar .logo{display:flex;align-items:center;gap:6px;padding:0 10px;font-size:.85rem;font-weight:700;color:var(--ink);text-shadow:var(--glow);white-space:nowrap;font-family:'Noto Naskh Arabic',serif;}
.topbar .divider{width:1px;height:24px;background:var(--border);margin:0 6px;}
.tb-group{display:flex;align-items:center;gap:2px;}

.tb-btn{background:none;border:none;color:var(--text2);width:32px;height:32px;border-radius:var(--radius);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:1rem;transition:var(--transition);position:relative;}
.tb-btn:hover{background:#ffffff10;color:var(--text);}
.tb-btn.active{color:var(--ink);background:#00f5d410;}
.tb-btn:disabled{opacity:.3;cursor:default;}

.tb-label{font-size:.7rem;color:var(--text2);margin:0 4px;white-space:nowrap;}

/* Shape fill toggle */
.shape-fill-row{display:flex;align-items:center;gap:6px;}
.fill-toggle{display:flex;align-items:center;gap:6px;cursor:pointer;user-select:none;}
.fill-toggle input{display:none;}
.fill-toggle-slider{position:relative;width:28px;height:16px;background:#333;border-radius:8px;transition:background .2s;flex-shrink:0;}
.fill-toggle-slider::after{content:'';position:absolute;top:2px;left:2px;width:12px;height:12px;background:#888;border-radius:50%;transition:transform .2s, background .2s;}
.fill-toggle input:checked + .fill-toggle-slider{background:var(--ink);}
.fill-toggle input:checked + .fill-toggle-slider::after{transform:translateX(12px);background:#fff;}
.fill-toggle-label{font-size:.68rem;color:var(--text2);white-space:nowrap;}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CAMERA AREA â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.camera-area{position:relative;overflow:hidden;background:var(--bg);}

#videoElement{position:fixed;top:0;left:0;width:100vw;height:100vh;object-fit:cover;opacity:0;transform:scaleX(-1);z-index:200;pointer-events:none;transition:opacity .3s;}
#videoElement.visible{opacity:1;}
#handCanvas{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:204;pointer-events:none;transform:scaleX(-1);display:none;}

.cam-draw-overlay{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:201;pointer-events:none;display:none;}
.cam-draw-overlay.active{display:block;pointer-events:auto;}

#camGridCanvas{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:203;pointer-events:none;display:none;}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STATUSBAR â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.statusbar{grid-column:1/-1;display:flex;align-items:center;padding:0 12px;background:var(--panel);border-top:1px solid var(--border);font-size:.68rem;color:var(--text2);gap:16px;z-index:250;}
.statusbar .dot{width:6px;height:6px;border-radius:50%;background:#555;transition:background .2s;}
.statusbar .dot.active{background:var(--ink);box-shadow:0 0 8px var(--ink);}
.statusbar .dot.drawing{background:var(--accent);box-shadow:0 0 8px var(--accent);}
.status-group{display:flex;align-items:center;gap:4px;}
.statusbar .sep{width:1px;height:14px;background:var(--border);}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• OVERLAY (START) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.overlay-start{position:fixed;inset:0;background:rgba(10,10,20,.92);z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:20px;text-align:center;padding:40px;backdrop-filter:blur(10px);}
.overlay-start.hidden{display:none;}
.overlay-start h2{font-size:2.4rem;color:var(--ink);text-shadow:var(--glow);font-family:'Noto Naskh Arabic',serif;}
.overlay-start p{font-size:.95rem;color:#aaa;max-width:440px;line-height:1.9;font-family:'Noto Naskh Arabic',serif;}
.start-options{display:flex;gap:16px;margin-top:10px;flex-wrap:wrap;justify-content:center;}
.big-btn{padding:14px 36px;font-size:1rem;border:none;border-radius:var(--radius);font-weight:700;cursor:pointer;transition:var(--transition);font-family:inherit;}
.big-btn.primary{background:var(--ink);color:var(--bg);}
.big-btn.primary:hover{background:#00c9b0;box-shadow:var(--glow);}

.instruction-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;max-width:500px;margin-top:10px;}
.instr-card{background:#ffffff06;border:1px solid #ffffff12;border-radius:10px;padding:12px 16px;font-size:.82rem;color:#ccc;line-height:1.6;font-family:'Noto Naskh Arabic',serif;}
.instr-card span{display:block;font-size:1.5rem;margin-bottom:4px;}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MODAL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:10000;display:none;align-items:center;justify-content:center;backdrop-filter:blur(4px);}
.modal-backdrop.show{display:flex;}
.modal{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:24px;min-width:360px;max-width:500px;box-shadow:0 20px 60px rgba(0,0,0,.5);}
.modal h3{font-size:1rem;color:var(--ink);margin-bottom:16px;}
.modal-row{display:flex;align-items:center;gap:10px;margin-bottom:12px;}
.modal-row label{font-size:.8rem;color:var(--text2);min-width:80px;}
.modal-row input,.modal-row select{background:var(--panel2);border:1px solid var(--border);color:var(--text);padding:6px 10px;border-radius:6px;font-size:.8rem;flex:1;font-family:inherit;}
.modal-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:18px;}
.modal-btn{padding:8px 20px;border-radius:6px;font-size:.8rem;cursor:pointer;border:none;font-family:inherit;transition:var(--transition);}
.modal-btn.primary{background:var(--ink);color:var(--bg);font-weight:600;}
.modal-btn.primary:hover{background:#00c9b0;}
.modal-btn.cancel{background:transparent;color:var(--text2);border:1px solid var(--border);}
.modal-btn.cancel:hover{background:#ffffff08;}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• FULLSCREEN MODE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.app.fullscreen .topbar{display:none;}
.app.fullscreen .statusbar{display:none;}
.app.fullscreen{grid-template-columns:1fr;grid-template-rows:0 1fr 0;}

.fs-exit-btn{position:fixed;top:10px;left:10px;z-index:9998;background:rgba(18,18,42,.85);border:1px solid var(--border);color:var(--ink);width:40px;height:40px;border-radius:8px;cursor:pointer;font-size:1.2rem;display:none;align-items:center;justify-content:center;backdrop-filter:blur(6px);transition:all .2s;}
.fs-exit-btn:hover{background:rgba(0,245,212,.15);transform:scale(1.1);}
.app.fullscreen~.fs-exit-btn{display:flex;}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• NO CAMERA PLACEHOLDER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.no-cam-msg{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;color:var(--text2);font-size:1.2rem;gap:12px;}
.no-cam-msg span{font-size:3rem;}
</style>
</head>
<body>

<!-- Fullscreen exit button -->
<button class="fs-exit-btn" id="fsExitBtn" title="Exit Fullscreen (F11 / Esc)" onclick="toggleFullscreen()">âœ•</button>

<!-- â•â•â•â•â•â•â•â•â•â•â• START OVERLAY â•â•â•â•â•â•â•â•â•â•â• -->
<div class="overlay-start" id="startOverlay">
  <h2>âœï¸ Ù†ÙˆÙˆØ³ÛŒÙ†ÛŒ Ù‡Û•ÙˆØ§ÛŒÛŒ</h2>
  <p>Ø¨Û• Ù¾Û•Ù†Ø¬Û•Øª Ù„Û• Ù‡Û•ÙˆØ§Ø¯Ø§ Ø¨Ù†ÙˆÙˆØ³Û• Ø¨Û• Ú©Ø§Ù…ÛØ±Ø§</p>

  <div class="instruction-grid">
    <div class="instr-card"><span>â˜ï¸</span>Ù¾Û•Ù†Ø¬Û•ÛŒ Ù†ÛŒØ´Ø§Ù†Û• ØªÛ•Ù†Ù‡Ø§ = Ù†ÙˆÙˆØ³ÛŒÙ†</div>
    <div class="instr-card"><span>âœŒï¸</span>Ø¯ÙˆÙˆ Ù¾Û•Ù†Ø¬Û• = Ù‚Û•ÚµÛ•Ù… Ù‡Û•ÚµØ¨Ú¯Ø±Û•</div>
    <div class="instr-card"><span>ğŸ¤</span>Ù¾Û•Ù†Ø¬Û• + Ù¾Û•Ù†Ø¬Û•Ú¯Û•ÙˆØ±Û• = Ú¯ÙˆØ§Ø³ØªÙ†Û•ÙˆÛ•</div>
    <div class="instr-card"><span>ğŸ¤š</span>Ø¦Û•Ù„ÛŒ Ú©Ù = Ù¾Ø§Ú©Ø±Ø¯Ù†Û•ÙˆÛ•</div>
  </div>

  <div class="start-options">
    <button class="big-btn primary" onclick="startApp()">Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø±Ø¯Ù† ğŸ“·</button>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â• MAIN APP â•â•â•â•â•â•â•â•â•â•â• -->
<div class="app">

  <!-- TOP BAR -->
  <div class="topbar">
    <div class="logo">âœï¸ Ù‡Û•ÙˆØ§ÛŒÛŒ</div>
    <div class="divider"></div>

    <div class="tb-group">
      <button class="tb-btn" id="btnUndo" title="Undo" onclick="camUndo()">â†©</button>
    </div>
    <div class="divider"></div>

    <div class="tb-group">
      <button class="tb-btn" id="btnGrid" title="Grid (G)" onclick="toggleGrid()">â–¦</button>
      <button class="tb-btn" id="btnSymmetry" title="Symmetry (S)" onclick="toggleSymmetry()">âŒ</button>
    </div>
    <div class="divider"></div>

    <!-- INLINE COLOR SWATCHES -->
    <div class="tb-group tb-color-row">
      <div class="tb-color-current" id="tbColorCurrent" style="background:#00f5d4;" title="Custom Color">
        <input type="color" id="tbColorPicker" value="#00f5d4" oninput="tbPickColor(this.value)">
      </div>
      <div class="tb-swatch active" style="background:#00f5d4" onclick="tbSetColor(this,'#00f5d4')"></div>
      <div class="tb-swatch" style="background:#f72585" onclick="tbSetColor(this,'#f72585')"></div>
      <div class="tb-swatch" style="background:#ffffff" onclick="tbSetColor(this,'#ffffff')"></div>
      <div class="tb-swatch" style="background:#ffd60a" onclick="tbSetColor(this,'#ffd60a')"></div>
      <div class="tb-swatch" style="background:#7b2fff" onclick="tbSetColor(this,'#7b2fff')"></div>
      <div class="tb-swatch" style="background:#0099ff" onclick="tbSetColor(this,'#0099ff')"></div>
      <div class="tb-swatch" style="background:#ff6600" onclick="tbSetColor(this,'#ff6600')"></div>
      <div class="tb-swatch" style="background:#00ff00" onclick="tbSetColor(this,'#00ff00')"></div>
    </div>
    <div class="divider"></div>

    <!-- INLINE SIZE SLIDER -->
    <div class="tb-group tb-size-slider">
      <span class="tb-label">Ù‚Û•Ø¨Ø§Ø±Û•:</span>
      <input type="range" id="tbSizeSlider" min="1" max="60" value="8" oninput="tbSetSize(this.value)">
      <span class="tb-size-val" id="tbSizeVal">8</span>
    </div>
    <div class="divider"></div>

    <!-- AUTO-FILL TOGGLE -->
    <div class="tb-group shape-fill-row">
      <label class="fill-toggle">
        <input type="checkbox" id="shapeFillCheck" onchange="toggleShapeFill(this.checked)">
        <span class="fill-toggle-slider"></span>
        <span class="fill-toggle-label">Ù¾Ú•Ú©Ø±Ø¯Ù†Û•ÙˆÛ•</span>
      </label>
    </div>
    <div class="divider"></div>

    <!-- BRUSH STYLE -->
    <div class="tb-group">
      <span class="tb-label">Ø´ÛÙˆØ§Ø²:</span>
      <select class="tb-btn" id="brushStyle" onchange="setBrushStyle(this.value)" style="width:auto;font-size:.72rem;padding:0 4px;">
        <option value="normal">Ø¦Ø§Ø³Ø§ÛŒÛŒ</option>
        <option value="neon">Ù†ÛŒÛ†Ù†</option>
      </select>
    </div>

    <div style="flex:1;"></div>

    <div class="tb-group">
      <button class="tb-btn" title="Clear Drawing" onclick="tbClearDraw()">ğŸ—‘</button>
      <button class="tb-btn" title="Export" onclick="showExportModal()">ğŸ’¾</button>
      <button class="tb-btn" id="btnFullscreen" title="Fullscreen (F11)" onclick="toggleFullscreen()">â›¶</button>
    </div>
  </div>

  <!-- CAMERA AREA -->
  <div class="camera-area" id="cameraArea">
    <div class="no-cam-msg" id="noCamMsg">
      <span>ğŸ“·</span>
      <div>Ú©Ø§Ù…ÛØ±Ø§ Ú†Ø§Ù„Ø§Ú© Ù†Û•Ú©Ø±Ø§ÙˆÛ•</div>
    </div>
  </div>

  <!-- Full-screen camera layers -->
  <video id="videoElement" autoplay playsinline muted></video>
  <canvas id="camDrawCanvas" class="cam-draw-overlay"></canvas>
  <canvas id="camGridCanvas"></canvas>
  <canvas id="handCanvas"></canvas>

  <!-- STATUS BAR -->
  <div class="statusbar">
    <div class="status-group">
      <div class="dot" id="camDot"></div>
      <span id="statusCam">Ú©Ø§Ù…ÛØ±Ø§ Ù†Ø§Ú†Ø§Ù„Ø§Ú©Û•</span>
    </div>
    <div class="sep"></div>
    <div class="status-group">
      <div class="dot" id="drawDot"></div>
      <span id="statusDraw">Ø¦Ø§Ù…Ø§Ø¯Û•ÛŒÛ•</span>
    </div>
    <div style="flex:1;"></div>
    <span id="statusFPS" style="color:var(--ink);"></span>
  </div>
</div>

<!-- EXPORT MODAL -->
<div class="modal-backdrop" id="exportModal">
  <div class="modal">
    <h3>ğŸ’¾ Ù‡Û•Ù†Ø§Ø±Ø¯Û•Ú©Ø±Ø¯Ù†</h3>
    <div class="modal-row">
      <label>ÙÛ†Ø±Ù…Ø§Øª:</label>
      <select id="exportFormat">
        <option value="png">PNG (Transparent)</option>
        <option value="jpg">JPEG</option>
        <option value="webp">WebP</option>
      </select>
    </div>
    <div class="modal-row">
      <label>Ú©ÙˆØ§Ù„ÛŒØªÛŒ:</label>
      <input type="range" id="exportQuality" min="10" max="100" value="95" style="flex:1;" oninput="document.getElementById('exportQualityVal').textContent=this.value+'%'">
      <span id="exportQualityVal" style="min-width:30px;text-align:left;font-size:.8rem;color:var(--ink);">95%</span>
    </div>
    <div class="modal-row">
      <label>Ù¾Ø§Ø´Ø¨Ù†Û•Ù…Ø§:</label>
      <select id="exportBg">
        <option value="transparent">Transparent</option>
        <option value="#0b0b16">Dark</option>
        <option value="#ffffff">White</option>
        <option value="#000000">Black</option>
      </select>
    </div>
    <div class="modal-actions">
      <button class="modal-btn cancel" onclick="closeModal('exportModal')">Ù¾Ø§Ø´Ú¯Û•Ø²Ø¨ÙˆÙˆÙ†Û•ÙˆÛ•</button>
      <button class="modal-btn primary" onclick="doExport()">Ù‡Û•Ù†Ø§Ø±Ø¯Û•Ú©Ø±Ø¯Ù†</button>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- JAVASCRIPT -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const state = {
  color: { h:170, s:100, l:55, a:1 },
  colorHex: '#00f5d4',
  size: 8,
  softness: 0,
  flow: 100,
  showGrid: false,
  gridSize: 20,
  symmetry: 'none',
  cameraOn: false,
  shapeFill: false,
  brushStyle: 'normal', // 'normal' | 'neon'
};

// FPS counter
let frameCount = 0, lastFpsTime = performance.now();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOM REFS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const handCanvas    = document.getElementById('handCanvas');
const video         = document.getElementById('videoElement');
const camDrawCanvas = document.getElementById('camDrawCanvas');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startApp() {
  document.getElementById('startOverlay').classList.add('hidden');
  startCamera();
  requestAnimationFrame(fpsLoop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLOR HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function hslToHex(h, s, l) {
  s /= 100; l /= 100;
  const f = n => { const k = (n + h / 30) % 12; const c = s * Math.min(l, 1 - l); return l - c * Math.max(-1, Math.min(k - 3, 9 - k, 1)); };
  const hx = x => Math.round(x * 255).toString(16).padStart(2, '0');
  return '#' + hx(f(0)) + hx(f(8)) + hx(f(4));
}

function hslToRgba(h, s, l, a) {
  if (a === undefined) a = 1;
  const hex = hslToHex(h, s, l);
  const r = parseInt(hex.slice(1,3), 16), g = parseInt(hex.slice(3,5), 16), b = parseInt(hex.slice(5,7), 16);
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}

function hexToHsl(hex) {
  hex = hex.replace('#', '');
  const r = parseInt(hex.slice(0,2),16)/255, g = parseInt(hex.slice(2,4),16)/255, b = parseInt(hex.slice(4,6),16)/255;
  const mx = Math.max(r,g,b), mn = Math.min(r,g,b), d = mx - mn;
  let h = 0, s = 0, l = (mx + mn) / 2;
  if (d) {
    s = l > .5 ? d / (2 - mx - mn) : d / (mx + mn);
    if (mx === r) h = ((g - b) / d + (g < b ? 6 : 0)) * 60;
    else if (mx === g) h = ((b - r) / d + 2) * 60;
    else h = ((r - g) / d + 4) * 60;
  }
  return { h: Math.round(h), s: Math.round(s * 100), l: Math.round(l * 100), a: 1 };
}

function getDrawColor() {
  return hslToRgba(state.color.h, state.color.s, state.color.l, state.color.a * (state.flow / 100));
}

function getShapeFillColor() {
  return getDrawColor();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOPBAR CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function tbSetColor(el, hex) {
  document.querySelectorAll('.tb-swatch').forEach(s => s.classList.remove('active'));
  el.classList.add('active');
  const hsl = hexToHsl(hex.replace('#', ''));
  state.color = { ...hsl, a: state.color.a };
  state.colorHex = hex;
  document.getElementById('tbColorCurrent').style.background = hex;
  document.getElementById('tbColorPicker').value = hex;
}

function tbPickColor(hex) {
  document.querySelectorAll('.tb-swatch').forEach(s => s.classList.remove('active'));
  const hsl = hexToHsl(hex.replace('#', ''));
  state.color = { ...hsl, a: state.color.a };
  state.colorHex = hex;
  document.getElementById('tbColorCurrent').style.background = hex;
}

function tbSetSize(val) {
  state.size = parseInt(val);
  document.getElementById('tbSizeVal').textContent = val;
}

function toggleShapeFill(on) {
  state.shapeFill = on;
}

function setBrushStyle(v) {
  state.brushStyle = v;
}

function tbClearDraw() {
  camSaveState();
  camDrawCanvas.getContext('2d').clearRect(0, 0, camDrawCanvas.width, camDrawCanvas.height);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GRID & SYMMETRY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function toggleGrid() {
  state.showGrid = !state.showGrid;
  document.getElementById('btnGrid').classList.toggle('active', state.showGrid);
  drawCamGrid(state.showGrid);
}

function drawCamGrid(show) {
  const camGrid = document.getElementById('camGridCanvas');
  if (!camGrid) return;
  if (!show || !state.cameraOn) { camGrid.style.display = 'none'; return; }
  camGrid.style.display = 'block';
  camGrid.width = window.innerWidth; camGrid.height = window.innerHeight;
  const ctx = camGrid.getContext('2d');
  ctx.clearRect(0, 0, camGrid.width, camGrid.height);
  const step = state.gridSize * 3;
  if (step < 4) return;
  ctx.strokeStyle = '#ffffff20'; ctx.lineWidth = 1;
  for (let x = 0; x < camGrid.width; x += step) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, camGrid.height); ctx.stroke(); }
  for (let y = 0; y < camGrid.height; y += step) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(camGrid.width, y); ctx.stroke(); }
}

function toggleSymmetry() {
  const modes = ['none','vertical','horizontal','both'];
  state.symmetry = modes[(modes.indexOf(state.symmetry) + 1) % modes.length];
  const b = document.getElementById('btnSymmetry');
  b.classList.toggle('active', state.symmetry !== 'none');
  b.title = 'Symmetry: ' + state.symmetry;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FULLSCREEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function toggleFullscreen() {
  const app = document.querySelector('.app');
  const exitBtn = document.getElementById('fsExitBtn');
  app.classList.toggle('fullscreen');
  const isFs = app.classList.contains('fullscreen');
  exitBtn.style.display = isFs ? 'flex' : 'none';
  document.getElementById('btnFullscreen')?.classList.toggle('active', isFs);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT (from camera draw canvas)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showExportModal() { document.getElementById('exportModal').classList.add('show'); }
function closeModal(id) { document.getElementById(id).classList.remove('show'); }

document.querySelectorAll('.modal-backdrop').forEach(m => {
  m.addEventListener('click', e => { if (e.target === m) m.classList.remove('show'); });
});

function doExport() {
  const fmt = document.getElementById('exportFormat').value;
  const q = parseInt(document.getElementById('exportQuality').value) / 100;
  const bg = document.getElementById('exportBg').value;

  const e = document.createElement('canvas');
  e.width = camDrawCanvas.width; e.height = camDrawCanvas.height;
  const ctx = e.getContext('2d');
  if (bg !== 'transparent') { ctx.fillStyle = bg; ctx.fillRect(0, 0, e.width, e.height); }
  ctx.drawImage(camDrawCanvas, 0, 0);

  const mime = fmt === 'jpg' ? 'image/jpeg' : fmt === 'webp' ? 'image/webp' : 'image/png';
  const ext = fmt === 'jpg' ? 'jpg' : fmt === 'webp' ? 'webp' : 'png';
  const a = document.createElement('a');
  a.download = 'air-write-' + Date.now() + '.' + ext;
  a.href = e.toDataURL(mime, q);
  a.click();
  closeModal('exportModal');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HAND TRACKING (MediaPipe)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let handsModel = null;
let airLastPt = null;
let airPathPoints = [];
let lastUndoGestureTime = 0;
let camUndoStack = [];
const MAX_CAM_UNDO = 30;

// Pinch-to-move state
let camMoveState = {
  phase: 'idle',
  snapshot: null,
  snapshotBounds: null,
  startPt: null,
  smoothPt: null,
  confirmStart: 0,
  pinchFrames: 0,
  totalDx: 0,
  totalDy: 0,
};
const PINCH_START_DIST = 50;
const PINCH_END_DIST = 75;
const PINCH_CONFIRM_MS = 250;
const PINCH_CONFIRM_FRAMES = 6;
const MOVE_SMOOTH = 0.35;
const PINCH_DRAW_COOLDOWN = 400;
let lastPinchEndTime = 0;

let _moveOffscreen = null;
function getMoveOffscreen(w, h) {
  if (!_moveOffscreen || _moveOffscreen.width !== w || _moveOffscreen.height !== h) {
    _moveOffscreen = document.createElement('canvas');
    _moveOffscreen.width = w; _moveOffscreen.height = h;
  }
  return _moveOffscreen;
}

function getContentBounds(canvas) {
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const data = ctx.getImageData(0, 0, w, h).data;
  let minX = w, minY = h, maxX = 0, maxY = 0;
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      if (data[(y * w + x) * 4 + 3] > 10) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
    }
  }
  if (maxX < minX) return null;
  return { x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY + 1 };
}

function smoothPt(cur, target, factor) {
  return {
    x: cur.x + (target.x - cur.x) * (1 - factor),
    y: cur.y + (target.y - cur.y) * (1 - factor),
  };
}

function drawMoveUI(hCtx, midPt, phase, progress, bounds, dx, dy) {
  hCtx.save();

  if (phase === 'confirm') {
    const radius = 28;
    const angle = progress * Math.PI * 2;
    hCtx.beginPath(); hCtx.arc(midPt.x, midPt.y, radius, 0, Math.PI * 2);
    hCtx.strokeStyle = '#ffffff30'; hCtx.lineWidth = 4; hCtx.stroke();
    hCtx.beginPath(); hCtx.arc(midPt.x, midPt.y, radius, -Math.PI / 2, -Math.PI / 2 + angle);
    hCtx.strokeStyle = '#ffd60a'; hCtx.lineWidth = 4;
    hCtx.shadowBlur = 15; hCtx.shadowColor = '#ffd60a';
    hCtx.stroke(); hCtx.shadowBlur = 0;
    hCtx.beginPath(); hCtx.arc(midPt.x, midPt.y, 5, 0, Math.PI * 2);
    hCtx.fillStyle = '#ffd60a'; hCtx.fill();
    hCtx.fillStyle = '#ffd60a'; hCtx.font = 'bold 13px Inter, sans-serif';
    hCtx.textAlign = 'center'; hCtx.textBaseline = 'bottom';
    hCtx.fillText('ğŸ¤ Ú¯Ø±ØªÙ†...', midPt.x, midPt.y - 36);
  }

  if (phase === 'moving') {
    hCtx.beginPath(); hCtx.arc(midPt.x, midPt.y, 22, 0, Math.PI * 2);
    hCtx.fillStyle = 'rgba(255,214,10,.15)'; hCtx.fill();
    hCtx.strokeStyle = '#ffd60a'; hCtx.lineWidth = 3;
    hCtx.shadowBlur = 20; hCtx.shadowColor = '#ffd60a';
    hCtx.stroke(); hCtx.shadowBlur = 0;
    const as = 10;
    hCtx.strokeStyle = '#ffd60a'; hCtx.lineWidth = 2;
    [[-1,0],[1,0],[0,-1],[0,1]].forEach(([ax,ay]) => {
      const bx = midPt.x + ax * 30, by = midPt.y + ay * 30;
      hCtx.beginPath(); hCtx.moveTo(midPt.x + ax * 14, midPt.y + ay * 14); hCtx.lineTo(bx, by);
      hCtx.moveTo(bx, by); hCtx.lineTo(bx - ax * as + ay * (as/2), by - ay * as + ax * (as/2));
      hCtx.moveTo(bx, by); hCtx.lineTo(bx - ax * as - ay * (as/2), by - ay * as - ax * (as/2));
      hCtx.stroke();
    });
    hCtx.fillStyle = '#ffd60a'; hCtx.font = 'bold 13px Inter, sans-serif';
    hCtx.textAlign = 'center'; hCtx.textBaseline = 'bottom';
    const dist = Math.round(Math.hypot(dx, dy));
    hCtx.fillText('ğŸ“¦ Ú¯ÙˆØ§Ø³ØªÙ†Û•ÙˆÛ•  (' + dist + 'px)', midPt.x, midPt.y - 40);

    if (bounds) {
      hCtx.setLineDash([6, 4]);
      hCtx.strokeStyle = 'rgba(255,255,255,.25)'; hCtx.lineWidth = 1.5;
      hCtx.strokeRect(bounds.x - 2, bounds.y - 2, bounds.w + 4, bounds.h + 4);
      hCtx.strokeStyle = '#ffd60a80'; hCtx.lineWidth = 1.5;
      hCtx.strokeRect(bounds.x + dx - 2, bounds.y + dy - 2, bounds.w + 4, bounds.h + 4);
      hCtx.setLineDash([]);
    }
  }

  hCtx.restore();
}

function camSaveState() {
  if (!camDrawCanvas.width || !camDrawCanvas.height) return;
  const cCtx = camDrawCanvas.getContext('2d');
  camUndoStack.push(cCtx.getImageData(0, 0, camDrawCanvas.width, camDrawCanvas.height));
  if (camUndoStack.length > MAX_CAM_UNDO) camUndoStack.shift();
}

function camUndo() {
  if (!camUndoStack.length) return;
  const imgData = camUndoStack.pop();
  const cCtx = camDrawCanvas.getContext('2d');
  cCtx.clearRect(0, 0, camDrawCanvas.width, camDrawCanvas.height);
  cCtx.putImageData(imgData, 0, 0);
}

function startCamera() {
  handsModel = new Hands({ locateFile: f => 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/' + f });
  handsModel.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.6 });
  handsModel.onResults(onHandResults);

  const cam = new Camera(video, {
    onFrame: async () => { if (handsModel) await handsModel.send({ image: video }); },
    width: 1280, height: 720
  });

  cam.start().then(() => {
    state.cameraOn = true;
    video.classList.add('visible');
    camDrawCanvas.classList.add('active');
    camDrawCanvas.width = window.innerWidth;
    camDrawCanvas.height = window.innerHeight;
    handCanvas.style.display = 'block';
    handCanvas.width = window.innerWidth;
    handCanvas.height = window.innerHeight;
    document.getElementById('camDot').classList.add('active');
    document.getElementById('statusCam').textContent = 'Ú©Ø§Ù…ÛØ±Ø§ Ú†Ø§Ù„Ø§Ú©Û• âœ“';
    document.getElementById('noCamMsg').style.display = 'none';
  }).catch(err => {
    document.getElementById('statusCam').textContent = 'Ù‡Û•ÚµÛ•: ' + err.message;
  });
}

function onHandResults(results) {
  const hCtx = handCanvas.getContext('2d');
  hCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);

  if (!results.multiHandLandmarks || !results.multiHandLandmarks.length) {
    airEnd();
    document.getElementById('drawDot').className = 'dot';
    document.getElementById('statusDraw').textContent = 'Ø¯Û•Ø³Øª Ù†Û•Ø¯ÛŒØªØ±Ø§ÙˆÛ•';
    return;
  }

  const lm = results.multiHandLandmarks[0];
  const W = window.innerWidth, H = window.innerHeight;
  const pt = (l) => ({ x: (1 - l.x) * W, y: l.y * H });

  const it = pt(lm[8]);
  const indexUp = lm[8].y < lm[6].y - 0.03;
  const middleUp = lm[12].y < lm[10].y - 0.03;
  const ringUp = lm[16].y < lm[14].y - 0.03;
  const pinkyUp = lm[20].y < lm[18].y - 0.03;
  const allUp = pinkyUp && ringUp && middleUp && indexUp;

  // Fingertip indicator
  hCtx.beginPath(); hCtx.arc(it.x, it.y, 14, 0, Math.PI * 2);
  hCtx.strokeStyle = state.colorHex; hCtx.lineWidth = 2.5;
  hCtx.shadowBlur = 20; hCtx.shadowColor = state.colorHex;
  hCtx.stroke(); hCtx.shadowBlur = 0;

  // Skeleton
  const conns = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
  hCtx.strokeStyle = '#ffffff20'; hCtx.lineWidth = 1;
  conns.forEach(([a,b]) => { const pa = pt(lm[a]), pb = pt(lm[b]); hCtx.beginPath(); hCtx.moveTo(pa.x, pa.y); hCtx.lineTo(pb.x, pb.y); hCtx.stroke(); });

  const cCtx = camDrawCanvas.getContext('2d');

  // â”€â”€ Detect pinch â”€â”€
  const thumbTip = pt(lm[4]);
  const pinchDist = Math.hypot(thumbTip.x - it.x, thumbTip.y - it.y);
  const wasPinching = camMoveState.phase !== 'idle';
  const pinchThreshold = wasPinching ? PINCH_END_DIST : PINCH_START_DIST;
  const isPinching = pinchDist < pinchThreshold;
  const pinchGesture = isPinching && indexUp && !middleUp && !ringUp && !pinkyUp;

  // â”€â”€ PINCH TO MOVE â”€â”€
  if (pinchGesture) {
    airEnd();
    const rawMid = { x: (thumbTip.x + it.x) / 2, y: (thumbTip.y + it.y) / 2 };

    if (camMoveState.phase === 'idle') {
      camMoveState.phase = 'confirm';
      camMoveState.confirmStart = performance.now();
      camMoveState.pinchFrames = 1;
      camMoveState.smoothPt = { x: rawMid.x, y: rawMid.y };
      drawMoveUI(hCtx, rawMid, 'confirm', 0, null, 0, 0);
      document.getElementById('drawDot').className = 'dot active';
      document.getElementById('statusDraw').textContent = 'ğŸ¤ Ú¯Ø±ØªÙ† Ø¨Û† Ú¯ÙˆØ§Ø³ØªÙ†Û•ÙˆÛ•...';
      return;
    }

    camMoveState.smoothPt = smoothPt(camMoveState.smoothPt, rawMid, MOVE_SMOOTH);
    const midPt = camMoveState.smoothPt;

    if (camMoveState.phase === 'confirm') {
      camMoveState.pinchFrames++;
      const elapsed = performance.now() - camMoveState.confirmStart;
      const progress = Math.min(1, Math.max(elapsed / PINCH_CONFIRM_MS, camMoveState.pinchFrames / PINCH_CONFIRM_FRAMES));
      drawMoveUI(hCtx, midPt, 'confirm', progress, null, 0, 0);
      document.getElementById('statusDraw').textContent = 'ğŸ¤ Ú¯Ø±ØªÙ†... ' + Math.round(progress * 100) + '%';

      if (elapsed >= PINCH_CONFIRM_MS && camMoveState.pinchFrames >= PINCH_CONFIRM_FRAMES) {
        camSaveState();
        const snapshotCv = getMoveOffscreen(camDrawCanvas.width, camDrawCanvas.height);
        snapshotCv.getContext('2d').clearRect(0, 0, snapshotCv.width, snapshotCv.height);
        snapshotCv.getContext('2d').drawImage(camDrawCanvas, 0, 0);
        camMoveState.snapshot = document.createElement('canvas');
        camMoveState.snapshot.width = camDrawCanvas.width;
        camMoveState.snapshot.height = camDrawCanvas.height;
        camMoveState.snapshot.getContext('2d').drawImage(camDrawCanvas, 0, 0);
        camMoveState.snapshotBounds = getContentBounds(camDrawCanvas);
        camMoveState.startPt = { x: midPt.x, y: midPt.y };
        camMoveState.totalDx = 0;
        camMoveState.totalDy = 0;
        camMoveState.phase = 'moving';
      }
      return;
    }

    if (camMoveState.phase === 'moving') {
      const dx = midPt.x - camMoveState.startPt.x;
      const dy = midPt.y - camMoveState.startPt.y;
      camMoveState.totalDx = dx;
      camMoveState.totalDy = dy;
      cCtx.clearRect(0, 0, camDrawCanvas.width, camDrawCanvas.height);
      cCtx.drawImage(camMoveState.snapshot, dx, dy);
      drawMoveUI(hCtx, midPt, 'moving', 1, camMoveState.snapshotBounds, dx, dy);
      document.getElementById('drawDot').className = 'dot active';
      document.getElementById('statusDraw').textContent = 'ğŸ“¦ Ú¯ÙˆØ§Ø³ØªÙ†Û•ÙˆÛ•... (' + Math.round(Math.hypot(dx, dy)) + 'px)';
      return;
    }
    return;
  }

  // Pinch released
  if (camMoveState.phase === 'moving') {
    camMoveState.phase = 'idle';
    camMoveState.snapshot = null;
    camMoveState.snapshotBounds = null;
    camMoveState.startPt = null;
    camMoveState.smoothPt = null;
    lastPinchEndTime = performance.now();
    camSaveState();
    document.getElementById('statusDraw').textContent = 'âœ… Ú¯ÙˆØ§Ø³ØªØ±Ø§ÙˆÛ•!';
    setTimeout(() => {
      if (document.getElementById('statusDraw').textContent === 'âœ… Ú¯ÙˆØ§Ø³ØªØ±Ø§ÙˆÛ•!') {
        document.getElementById('statusDraw').textContent = 'Ø¦Ø§Ù…Ø§Ø¯Û•ÛŒÛ•';
      }
    }, 1200);
    return;
  } else if (camMoveState.phase === 'confirm') {
    camMoveState.phase = 'idle';
    camMoveState.smoothPt = null;
    camMoveState.confirmStart = 0;
    camMoveState.pinchFrames = 0;
    lastPinchEndTime = performance.now();
  }

  // ğŸ¤š All fingers up = clear
  if (allUp) {
    camSaveState();
    cCtx.clearRect(0, 0, camDrawCanvas.width, camDrawCanvas.height);
    airEnd();
    document.getElementById('drawDot').className = 'dot';
    document.getElementById('statusDraw').textContent = 'ğŸ¤š Ù¾Ø§Ú©Ú©Ø±Ø¯Ù†Û•ÙˆÛ•';
    return;
  }

  // ğŸ¤Ÿ Three fingers = undo
  if (indexUp && middleUp && ringUp && !pinkyUp) {
    airEnd();
    const now = Date.now();
    if (now - lastUndoGestureTime > 1000) {
      lastUndoGestureTime = now;
      camUndo();
    }
    document.getElementById('drawDot').className = 'dot';
    document.getElementById('statusDraw').textContent = 'ğŸ¤Ÿ Ú¯Û•Ú•Ø§Ù†Û•ÙˆÛ• (Undo)';
    return;
  }

  // âœŒï¸ Two fingers = pen up
  if (indexUp && middleUp) {
    airEnd();
    document.getElementById('drawDot').className = 'dot';
    document.getElementById('statusDraw').textContent = 'âœŒï¸ Ù‚Û•ÚµÛ•Ù… Ù‡Û•ÚµÚ¯ÛŒØ±Ø§ÙˆÛ•';
    return;
  }

  // â˜ï¸ One finger = draw
  if (indexUp && !middleUp) {
    if (pinchDist < PINCH_END_DIST || (performance.now() - lastPinchEndTime) < PINCH_DRAW_COOLDOWN) {
      airEnd();
      document.getElementById('drawDot').className = 'dot';
      if (pinchDist < PINCH_END_DIST) {
        document.getElementById('statusDraw').textContent = 'ğŸ¤ Ø¦Ø§Ù…Ø§Ø¯Û•ÛŒ Ú¯ÙˆØ§Ø³ØªÙ†Û•ÙˆÛ•...';
      }
      return;
    }
    if (!airLastPt) { camSaveState(); airPathPoints = [{ x: it.x, y: it.y }]; }
    document.getElementById('drawDot').classList.add('drawing');
    document.getElementById('statusDraw').textContent = 'â˜ï¸ Ù†ÙˆÙˆØ³ÛŒÙ†...';
    if (airLastPt) {
      airPathPoints.push({ x: it.x, y: it.y });
      cCtx.save();
      cCtx.strokeStyle = state.colorHex;
      cCtx.lineWidth = state.size;
      cCtx.lineCap = 'round'; cCtx.lineJoin = 'round';
      cCtx.globalAlpha = state.color.a * (state.flow / 100);
      if (state.brushStyle === 'neon') { cCtx.shadowBlur = state.size * 2.5; cCtx.shadowColor = state.colorHex; }
      else if (state.softness > 0) { cCtx.shadowBlur = state.softness * 0.5; cCtx.shadowColor = state.colorHex; }
      cCtx.beginPath();
      cCtx.moveTo(airLastPt.x, airLastPt.y);
      cCtx.lineTo(it.x, it.y);
      cCtx.stroke();
      cCtx.restore();
      // Symmetry mirrors
      if (state.symmetry !== 'none') {
        const cw = camDrawCanvas.width, ch = camDrawCanvas.height;
        const mirrors = [];
        if (state.symmetry === 'vertical' || state.symmetry === 'both') mirrors.push([-1, 1]);
        if (state.symmetry === 'horizontal' || state.symmetry === 'both') mirrors.push([1, -1]);
        if (state.symmetry === 'both') mirrors.push([-1, -1]);
        mirrors.forEach(([fx, fy]) => {
          const mF = { x: fx < 0 ? cw - airLastPt.x : airLastPt.x, y: fy < 0 ? ch - airLastPt.y : airLastPt.y };
          const mT = { x: fx < 0 ? cw - it.x : it.x, y: fy < 0 ? ch - it.y : it.y };
          cCtx.save();
          cCtx.strokeStyle = state.colorHex;
          cCtx.lineWidth = state.size;
          cCtx.lineCap = 'round'; cCtx.lineJoin = 'round';
          cCtx.globalAlpha = state.color.a * (state.flow / 100);
          if (state.brushStyle === 'neon') { cCtx.shadowBlur = state.size * 2.5; cCtx.shadowColor = state.colorHex; }
          cCtx.beginPath(); cCtx.moveTo(mF.x, mF.y); cCtx.lineTo(mT.x, mT.y); cCtx.stroke();
          cCtx.restore();
        });
      }
    }
    airLastPt = { x: it.x, y: it.y };
    return;
  }

  airEndAndFill(camDrawCanvas);
  document.getElementById('drawDot').className = 'dot';
  document.getElementById('statusDraw').textContent = 'Ù¾Û•Ù†Ø¬Û•Øª Ø¨Ù„Ù†Ø¯ Ø¨Ú©Û•';
}

function airEnd() {
  airLastPt = null;
  airPathPoints = [];
}

function airEndAndFill(canvas) {
  if (state.shapeFill && airPathPoints.length > 20) {
    const first = airPathPoints[0];
    const last = airPathPoints[airPathPoints.length - 1];
    const closeDist = Math.hypot(last.x - first.x, last.y - first.y);
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    airPathPoints.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); });
    const diag = Math.hypot(maxX - minX, maxY - minY);
    if (diag > 30 && closeDist < diag * 0.25) {
      const cCtx = canvas.getContext('2d');
      cCtx.save();
      cCtx.fillStyle = getShapeFillColor();
      cCtx.globalAlpha = state.color.a * (state.flow / 100);
      cCtx.beginPath();
      cCtx.moveTo(airPathPoints[0].x, airPathPoints[0].y);
      for (let i = 1; i < airPathPoints.length; i++) cCtx.lineTo(airPathPoints[i].x, airPathPoints[i].y);
      cCtx.closePath();
      cCtx.fill();
      cCtx.restore();
    }
  }
  airLastPt = null;
  airPathPoints = [];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYBOARD SHORTCUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('keydown', e => {
  if (['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName)) return;
  const k = e.key.toLowerCase();
  if (e.ctrlKey && k === 'z') { e.preventDefault(); camUndo(); return; }
  if (e.ctrlKey && e.shiftKey && k === 's') { e.preventDefault(); showExportModal(); return; }
  if (e.key === 'F11') { e.preventDefault(); toggleFullscreen(); return; }
  if (e.key === 'Escape' && document.querySelector('.app.fullscreen')) { e.preventDefault(); toggleFullscreen(); return; }
  if (k === 'g') { toggleGrid(); return; }
  if (k === 's' && !e.ctrlKey) { toggleSymmetry(); return; }
  if (k === '[') { state.size = Math.max(1, state.size - 2); document.getElementById('tbSizeSlider').value = state.size; document.getElementById('tbSizeVal').textContent = state.size; return; }
  if (k === ']') { state.size = Math.min(60, state.size + 2); document.getElementById('tbSizeSlider').value = state.size; document.getElementById('tbSizeVal').textContent = state.size; return; }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FPS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function fpsLoop(now) {
  frameCount++;
  if (now - lastFpsTime >= 1000) {
    document.getElementById('statusFPS').textContent = frameCount + ' FPS';
    frameCount = 0; lastFpsTime = now;
  }
  if (state.showGrid) drawCamGrid(true);
  requestAnimationFrame(fpsLoop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESIZE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function resizeOverlays() {
  if (state.cameraOn) {
    handCanvas.width = window.innerWidth;
    handCanvas.height = window.innerHeight;
    camDrawCanvas.width = window.innerWidth;
    camDrawCanvas.height = window.innerHeight;
    const camGrid = document.getElementById('camGridCanvas');
    if (camGrid && state.showGrid) {
      camGrid.width = window.innerWidth;
      camGrid.height = window.innerHeight;
    }
  }
  if (state.showGrid) drawCamGrid(true);
}
window.addEventListener('resize', resizeOverlays);
</script>
</body>
</html>
